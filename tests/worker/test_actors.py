import uuid

import mock
from fastapi.testclient import TestClient

from exodus_gw import models, worker
from exodus_gw.main import app


def _task(publish_id):
    return models.Task(
        id="8d8a4692-c89b-4b57-840f-b3f0166148d2",
        publish_id=publish_id,
        state="NOT_STARTED",
    )


@mock.patch("exodus_gw.worker.publish.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.publish.write_batches")
def test_commit(mock_write_batches, mock_get_message, mock_publish, db):
    # Construct task that would be generated by caller.
    task = _task(mock_publish.id)
    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(
        message_id=task.id, kwargs={"publish_id": mock_publish.id}
    )
    # Simulate successful write of items by write_batches.
    mock_write_batches.return_value = True

    with TestClient(app):
        db.add(mock_publish)
        db.add(task)
        db.commit()

    worker.commit(str(mock_publish.id), mock_publish.env)

    # It should've called write_batches for items and entry point items.
    mock_write_batches.assert_has_calls(
        calls=[
            mock.call("test", mock.ANY),
            mock.call("test", mock.ANY),
        ]
    )


@mock.patch("exodus_gw.worker.publish.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.publish.write_batches")
def test_commit_write_items_fail(
    mock_write_batches, mock_get_message, mock_publish, db
):
    # Construct task that would be generated by caller.
    task = _task(mock_publish.id)
    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(
        message_id=task.id, kwargs={"publish_id": mock_publish.id}
    )
    # Simulate failed write of items and successful deletion of items.
    mock_write_batches.side_effect = [False, True]

    with TestClient(app):
        db.add(mock_publish)
        db.add(task)
        db.commit()

    worker.commit(str(mock_publish.id), mock_publish.env)

    # It should've called write_batches for items and deletion of items.
    mock_write_batches.assert_has_calls(
        calls=[
            mock.call("test", mock.ANY),
            mock.call("test", mock.ANY, delete=True),
        ],
        any_order=False,
    )


@mock.patch("exodus_gw.worker.publish.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.publish.write_batches")
def test_commit_write_entry_point_items_fail(
    mock_write_batches, mock_get_message, mock_publish, db
):
    # Construct task that would be generated by caller.
    task = _task(mock_publish.id)
    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(
        message_id=task.id, kwargs={"publish_id": mock_publish.id}
    )
    # Simulate successful write of items, failed write of entry point items
    # and then successful deletion of items.
    mock_write_batches.side_effect = [True, False, True]

    with TestClient(app):
        db.add(mock_publish)
        db.add(task)
        db.commit()

    worker.commit(str(mock_publish.id), mock_publish.env)

    # It should've called write_batches for items, entry point items
    # and then deletion of all items.
    mock_write_batches.assert_has_calls(
        calls=[
            mock.call("test", mock.ANY),
            mock.call("test", mock.ANY),
            mock.call("test", mock.ANY, delete=True),
        ],
        any_order=False,
    )


@mock.patch("exodus_gw.worker.publish.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.publish.write_batches")
def test_commit_completed_task(
    mock_write_batches, mock_get_message, db, caplog
):
    # Construct task that would be generated by caller.
    task = _task(uuid.UUID("123e4567-e89b-12d3-a456-426614174000"))
    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(
        message_id=task.id, kwargs={"publish_id": task.publish_id}
    )

    with TestClient(app):
        db.add(task)
        # Simulate prior completion of task.
        task.state = "COMPLETE"
        db.commit()

    worker.commit(str(task.publish_id), "test")

    # It shouldn't have called write_batches.
    mock_write_batches.assert_not_called()

    # It should've logged a warning message.
    assert "already in completed state" in caplog.text
    assert "Aborting commit" in caplog.text
